-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [algos]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace algos

/- [algos::StateArray]
   Source: 'src/algos.rs', lines 7:0-7:30 -/
@[reducible] def StateArray := (Array U64 25#usize)

/- [algos::{core::clone::Clone for algos::StateArray}#6::clone]:
   Source: 'src/algos.rs', lines 6:9-6:14 -/
def ClonealgosStateArray.clone (self : StateArray) : Result StateArray :=
  ok self

/- Trait implementation: [algos::{core::clone::Clone for algos::StateArray}#6]
   Source: 'src/algos.rs', lines 6:9-6:14 -/
@[reducible]
def core.clone.ClonealgosStateArray : core.clone.Clone StateArray := {
  clone := ClonealgosStateArray.clone
}

/- Trait implementation: [algos::{core::marker::Copy for algos::StateArray}#7]
   Source: 'src/algos.rs', lines 6:16-6:20 -/
@[reducible]
def core.marker.CopyalgosStateArray : core.marker.Copy StateArray := {
  cloneInst := core.clone.ClonealgosStateArray
}

/- [algos::{core::default::Default for algos::StateArray}::default]:
   Source: 'src/algos.rs', lines 10:4-10:48 -/
def DefaultalgosStateArray.default : Result StateArray :=
  let a := Array.repeat 25#usize 0#u64
  ok a

/- Trait implementation: [algos::{core::default::Default for algos::StateArray}]
   Source: 'src/algos.rs', lines 9:0-11:1 -/
@[reducible]
def core.default.DefaultalgosStateArray : core.default.Default StateArray := {
  default := DefaultalgosStateArray.default
}

/- [algos::{core::ops::deref::Deref<@Array<u64, 25: usize>> for algos::StateArray}#1::deref]:
   Source: 'src/algos.rs', lines 15:4-15:48 -/
def DerefalgosStateArrayArrayU6425.deref
  (self : StateArray) : Result (Array U64 25#usize) :=
  ok self

/- Trait implementation: [algos::{core::ops::deref::Deref<@Array<u64, 25: usize>> for algos::StateArray}#1]
   Source: 'src/algos.rs', lines 13:0-16:1 -/
@[reducible]
def core.ops.deref.DerefalgosStateArrayArrayU6425 : core.ops.deref.Deref
  StateArray (Array U64 25#usize) := {
  deref := DerefalgosStateArrayArrayU6425.deref
}

/- [algos::{core::ops::deref::DerefMut<@Array<u64, 25: usize>> for algos::StateArray}#2::deref_mut]:
   Source: 'src/algos.rs', lines 18:4-18:64 -/
def DerefMutalgosStateArrayArrayU6425.deref_mut
  (self : StateArray) :
  Result ((Array U64 25#usize) × (Array U64 25#usize → StateArray))
  :=
  let back := fun ret => ret
  ok (self, back)

/- Trait implementation: [algos::{core::ops::deref::DerefMut<@Array<u64, 25: usize>> for algos::StateArray}#2]
   Source: 'src/algos.rs', lines 17:0-19:1 -/
@[reducible]
def core.ops.deref.DerefMutalgosStateArrayArrayU6425 : core.ops.deref.DerefMut
  StateArray (Array U64 25#usize) := {
  derefInst := core.ops.deref.DerefalgosStateArrayArrayU6425
  deref_mut := DerefMutalgosStateArrayArrayU6425.deref_mut
}

/- [algos::{core::ops::index::Index<(usize, usize), u64> for algos::StateArray}#3::index]:
   Source: 'src/algos.rs', lines 24:4-26:5 -/
def IndexalgosStateArrayPairUsizeUsizeU64.index
  (self : StateArray) (p : (Usize × Usize)) : Result U64 :=
  do
  let (x, y) := p
  let i ← 5#usize * y
  let i1 ← i + x
  Array.index_usize self i1

/- Trait implementation: [algos::{core::ops::index::Index<(usize, usize), u64> for algos::StateArray}#3]
   Source: 'src/algos.rs', lines 21:0-51:1 -/
@[reducible]
def core.ops.index.IndexalgosStateArrayPairUsizeUsizeU64 : core.ops.index.Index
  StateArray (Usize × Usize) U64 := {
  index := IndexalgosStateArrayPairUsizeUsizeU64.index
}

/- [algos::{core::ops::index::IndexMut<(usize, usize), u64> for algos::StateArray}#4::index_mut]:
   Source: 'src/algos.rs', lines 54:4-56:5 -/
def IndexMutalgosStateArrayPairUsizeUsizeU64.index_mut
  (self : StateArray) (p : (Usize × Usize)) :
  Result (U64 × (U64 → StateArray))
  :=
  do
  let (x, y) := p
  let i ← 5#usize * y
  let i1 ← i + x
  let (i2, index_mut_back) ← Array.index_mut_usize self i1
  let back := fun ret => let a := index_mut_back ret
                         a
  ok (i2, back)

/- Trait implementation: [algos::{core::ops::index::IndexMut<(usize, usize), u64> for algos::StateArray}#4]
   Source: 'src/algos.rs', lines 53:0-67:1 -/
@[reducible]
def core.ops.index.IndexMutalgosStateArrayPairUsizeUsizeU64 :
  core.ops.index.IndexMut StateArray (Usize × Usize) U64 := {
  indexInst := core.ops.index.IndexalgosStateArrayPairUsizeUsizeU64
  index_mut := IndexMutalgosStateArrayPairUsizeUsizeU64.index_mut
}

/- [algos::{algos::StateArray}#5::xor_byte_at]:
   Source: 'src/algos.rs', lines 70:4-76:5 -/
def StateArray.xor_byte_at
  (self : StateArray) (byte : U8) (pos : Usize) : Result StateArray :=
  do
  let lane_idx ← pos / 8#usize
  let offset ← pos % 8#usize
  let i ← Array.index_usize self lane_idx
  let buf ← (↑(core.num.U64.to_le_bytes i) : Result (Array U8 8#usize))
  let i1 ← Array.index_usize buf offset
  let i2 ← (↑(i1 ^^^ byte) : Result U8)
  let buf1 ← Array.update buf offset i2
  let i3 ← (↑(core.num.U64.from_le_bytes buf1) : Result U64)
  let a ← Array.update self lane_idx i3
  ok a

/- [algos::{algos::StateArray}#5::xor_lane::inner]: loop 0:
   Source: 'src/algos.rs', lines 81:12-84:13 -/
def StateArray.xor_lane.inner_loop
  (i : Usize) (buf : Array U8 8#usize) (src : Slice U8) :
  Result (Array U8 8#usize)
  :=
  let i1 := Slice.len src
  if i < i1
  then
    do
    let i2 ← Slice.index_usize src i
    let i3 ← Array.index_usize buf i
    let i4 ← (↑(i3 ^^^ i2) : Result U8)
    let buf1 ← Array.update buf i i4
    let i5 ← i + 1#usize
    StateArray.xor_lane.inner_loop i5 buf1 src
  else ok buf
partial_fixpoint

/- [algos::{algos::StateArray}#5::xor_lane::inner]:
   Source: 'src/algos.rs', lines 80:18-85:9 -/
@[reducible]
def StateArray.xor_lane.inner
  (i : Usize) (buf : Array U8 8#usize) (src : Slice U8) :
  Result (Array U8 8#usize)
  :=
  StateArray.xor_lane.inner_loop i buf src

/- [algos::{algos::StateArray}#5::xor_lane]:
   Source: 'src/algos.rs', lines 78:4-87:5 -/
def StateArray.xor_lane (dst : U64) (src : Slice U8) : Result U64 :=
  do
  let buf ← (↑(core.num.U64.to_le_bytes dst) : Result (Array U8 8#usize))
  let buf1 ← StateArray.xor_lane.inner 0#usize buf src
  ok (core.num.U64.from_le_bytes buf1)

/- [algos::{algos::StateArray}#5::xor::inner]: loop 0:
   Source: 'src/algos.rs', lines 94:12-97:13 -/
def StateArray.xor.inner_loop
  (this : StateArray) (block_idx : Usize) (other : Slice U8) :
  Result (StateArray × Usize)
  :=
  do
  let i ← 8#usize * block_idx
  let i1 ← i + 8#usize
  let i2 := Slice.len other
  if i1 <= i2
  then
    do
    let (i3, index_mut_back) ← Array.index_mut_usize this block_idx
    let i4 ← block_idx + 1#usize
    let i5 ← 8#usize * i4
    let s ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeUsizeSliceInst U8) other
        { start := i, end_ := i5 }
    let i6 ← StateArray.xor_lane i3 s
    let a := index_mut_back i6
    StateArray.xor.inner_loop a i4 other
  else ok (this, block_idx)
partial_fixpoint

/- [algos::{algos::StateArray}#5::xor::inner]:
   Source: 'src/algos.rs', lines 93:18-98:9 -/
@[reducible]
def StateArray.xor.inner
  (this : StateArray) (block_idx : Usize) (other : Slice U8) :
  Result (StateArray × Usize)
  :=
  StateArray.xor.inner_loop this block_idx other

/- [algos::{algos::StateArray}#5::xor]:
   Source: 'src/algos.rs', lines 90:4-102:5 -/
def StateArray.xor
  (self : StateArray) (other : Slice U8) : Result StateArray :=
  do
  let (self1, block_idx) ← StateArray.xor.inner self 0#usize other
  let i ← 8#usize * block_idx
  let i1 := Slice.len other
  if i < i1
  then
    do
    let (i2, index_mut_back) ← Array.index_mut_usize self1 block_idx
    let s ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeFromUsizeSlice U8) other
        { start := i }
    let i3 ← StateArray.xor_lane i2 s
    let a := index_mut_back i3
    ok a
  else ok self1

/- [algos::{algos::StateArray}#5::copy_to]: loop 0:
   Source: 'src/algos.rs', lines 1:0-114:9 -/
def StateArray.copy_to_loop
  (self : StateArray) (dst : Slice U8) (i : Usize) : Result (Slice U8) :=
  do
  let a ← DerefalgosStateArrayArrayU6425.deref self
  let s ← (↑(Array.to_slice a) : Result (Slice U64))
  let i1 := Slice.len s
  if i < i1
  then
    do
    let i2 ← 8#usize * i
    let i3 := Slice.len dst
    if i2 < i3
    then
      do
      let i4 ← i2 + 8#usize
      let i5 := Slice.len dst
      if i4 < i5
      then
        do
        let i6 ← i + 1#usize
        let i7 ← 8#usize * i6
        let (s1, index_mut_back) ←
          core.slice.index.Slice.index_mut
            (core.slice.index.SliceIndexRangeUsizeSliceInst U8) dst
            { start := i2, end_ := i7 }
        let i8 ← Array.index_usize self i
        let a1 ←
          (↑(core.num.U64.to_le_bytes i8) : Result (Array U8 8#usize))
        let s2 ←
          core.array.Array.index (core.ops.index.IndexSliceInst
            (core.slice.index.SliceIndexRangeFromUsizeSlice U8)) a1
            { start := 0#usize }
        let s3 ← core.slice.Slice.copy_from_slice core.marker.CopyU8 s1 s2
        let dst1 := index_mut_back s3
        StateArray.copy_to_loop self dst1 i6
      else
        do
        let i6 := Slice.len dst
        let nb_left ← i6 - i2
        let (s1, index_mut_back) ←
          core.slice.index.Slice.index_mut
            (core.slice.index.SliceIndexRangeFromUsizeSlice U8) dst
            { start := i2 }
        let i7 ← Array.index_usize self i
        let a1 ←
          (↑(core.num.U64.to_le_bytes i7) : Result (Array U8 8#usize))
        let s2 ←
          core.array.Array.index (core.ops.index.IndexSliceInst
            (core.slice.index.SliceIndexRangeUsizeSliceInst U8)) a1
            { start := 0#usize, end_ := nb_left }
        let s3 ← core.slice.Slice.copy_from_slice core.marker.CopyU8 s1 s2
        let i8 ← i + 1#usize
        let dst1 := index_mut_back s3
        StateArray.copy_to_loop self dst1 i8
    else ok dst
  else ok dst
partial_fixpoint

/- [algos::{algos::StateArray}#5::copy_to]:
   Source: 'src/algos.rs', lines 104:4-115:5 -/
@[reducible]
def StateArray.copy_to
  (self : StateArray) (dst : Slice U8) : Result (Slice U8) :=
  StateArray.copy_to_loop self dst 0#usize

/- [algos::W]
   Source: 'src/algos.rs', lines 123:0-123:20 -/
@[global_simps] def W_body : Result Usize := ok 64#usize
@[global_simps, irreducible] def W : Usize := eval_global W_body

/- [algos::theta::c]:
   Source: 'src/algos.rs', lines 126:4-128:5 -/
def theta.c (a : StateArray) (x : Usize) : Result U64 :=
  do
  let i ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x, 0#usize)
  let i1 ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x, 1#usize)
  let i2 ← (↑(i ^^^ i1) : Result U64)
  let i3 ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x, 2#usize)
  let i4 ← (↑(i2 ^^^ i3) : Result U64)
  let i5 ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x, 3#usize)
  let i6 ← (↑(i4 ^^^ i5) : Result U64)
  let i7 ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x, 4#usize)
  ok (i6 ^^^ i7)

/- [algos::theta::d]:
   Source: 'src/algos.rs', lines 129:4-133:5 -/
def theta.d (a : StateArray) (x : Usize) : Result U64 :=
  do
  let i ← x + 4#usize
  let x1 ← i % 5#usize
  let i1 ← x + 1#usize
  let x2 ← i1 % 5#usize
  let i2 ← theta.c a x1
  let i3 ← theta.c a x2
  let i4 ← (↑(core.num.U64.rotate_left i3 1#u32) : Result U64)
  ok (i2 ^^^ i4)

/- [algos::theta::inner::inner]:
   Source: 'src/algos.rs', lines 140:26-142:17 -/
def theta.inner.inner
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  do
  let i ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x, y)
  let i1 ← theta.d a x
  let (_, index_mut_back) ←
    IndexMutalgosStateArrayPairUsizeUsizeU64.index_mut res (x, y)
  let i2 ← (↑(i ^^^ i1) : Result U64)
  ok (index_mut_back i2)

/- [algos::theta::inner]: loop 0:
   Source: 'src/algos.rs', lines 139:12-144:13 -/
def theta.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  if y < 5#usize
  then
    do
    let res1 ← theta.inner.inner res a x y
    let y1 ← y + 1#usize
    theta.inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [algos::theta::inner]:
   Source: 'src/algos.rs', lines 137:18-145:9 -/
@[reducible]
def theta.inner
  (res : StateArray) (a : StateArray) (x : Usize) : Result StateArray :=
  theta.inner_loop res a x 0#usize

/- [algos::theta]: loop 0:
   Source: 'src/algos.rs', lines 136:4-147:5 -/
def theta_loop
  (a : StateArray) (res : StateArray) (x : Usize) : Result StateArray :=
  if x < 5#usize
  then
    do
    let res1 ← theta.inner res a x
    let x1 ← x + 1#usize
    theta_loop a res1 x1
  else ok res
partial_fixpoint

/- [algos::theta]:
   Source: 'src/algos.rs', lines 125:0-149:1 -/
def theta (a : StateArray) : Result StateArray :=
  do
  let res ← DefaultalgosStateArray.default
  theta_loop a res 0#usize

/- [algos::rho::offset]:
   Source: 'src/algos.rs', lines 152:4-154:5 -/
def rho.offset (t : U32) : Result U32 :=
  do
  let i ← t + 1#u32
  let i1 ← t + 2#u32
  let i2 ← i * i1
  let i3 ← i2 / 2#u32
  i3 % 64#u32

/- [algos::rho]: loop 0:
   Source: 'src/algos.rs', lines 158:4-162:5 -/
def rho_loop
  (a : StateArray) (x : Usize) (y : Usize) (a1 : StateArray) (t : U32) :
  Result StateArray
  :=
  if t < 24#u32
  then
    do
    let i ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x, y)
    let i1 ← rho.offset t
    let i2 ← (↑(core.num.U64.rotate_left i i1) : Result U64)
    let (_, index_mut_back) ←
      IndexMutalgosStateArrayPairUsizeUsizeU64.index_mut a1 (x, y)
    let i3 ← 2#usize * x
    let i4 ← 3#usize * y
    let i5 ← i3 + i4
    let y1 ← i5 % 5#usize
    let t1 ← t + 1#u32
    let res := index_mut_back i2
    rho_loop a y y1 res t1
  else ok a1
partial_fixpoint

/- [algos::rho]:
   Source: 'src/algos.rs', lines 151:0-164:1 -/
@[reducible]
def rho (a : StateArray) : Result StateArray :=
  rho_loop a 1#usize 0#usize a 0#u32

/- [algos::pi::inner]: loop 0:
   Source: 'src/algos.rs', lines 172:12-177:13 -/
def pi.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  if y < 5#usize
  then
    do
    let i ← 3#usize * y
    let i1 ← x + i
    let x2 ← i1 % 5#usize
    let i2 ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x2, x)
    let (_, index_mut_back) ←
      IndexMutalgosStateArrayPairUsizeUsizeU64.index_mut res (x, y)
    let y1 ← y + 1#usize
    let res1 := index_mut_back i2
    pi.inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [algos::pi::inner]:
   Source: 'src/algos.rs', lines 170:18-178:9 -/
@[reducible]
def pi.inner
  (res : StateArray) (a : StateArray) (x : Usize) : Result StateArray :=
  pi.inner_loop res a x 0#usize

/- [algos::pi]: loop 0:
   Source: 'src/algos.rs', lines 169:4-180:5 -/
def pi_loop
  (a : StateArray) (a1 : StateArray) (x : Usize) : Result StateArray :=
  if x < 5#usize
  then do
       let res ← pi.inner a1 a x
       let x1 ← x + 1#usize
       pi_loop a res x1
  else ok a1
partial_fixpoint

/- [algos::pi]:
   Source: 'src/algos.rs', lines 166:0-182:1 -/
@[reducible] def pi (a : StateArray) : Result StateArray :=
               pi_loop a a 0#usize

/- [algos::chi::inner]: loop 0:
   Source: 'src/algos.rs', lines 190:12-195:13 -/
def chi.inner_loop
  (res : StateArray) (a : StateArray) (x : Usize) (y : Usize) :
  Result StateArray
  :=
  if y < 5#usize
  then
    do
    let i ← x + 1#usize
    let x1 ← i % 5#usize
    let i1 ← x + 2#usize
    let x2 ← i1 % 5#usize
    let i2 ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x, y)
    let i3 ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x1, y)
    let i4 ← (↑(i3 ^^^ core.num.U64.MAX) : Result U64)
    let i5 ← IndexalgosStateArrayPairUsizeUsizeU64.index a (x2, y)
    let i6 ← (↑(i4 &&& i5) : Result U64)
    let (_, index_mut_back) ←
      IndexMutalgosStateArrayPairUsizeUsizeU64.index_mut res (x, y)
    let i7 ← (↑(i2 ^^^ i6) : Result U64)
    let y1 ← y + 1#usize
    let res1 := index_mut_back i7
    chi.inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [algos::chi::inner]:
   Source: 'src/algos.rs', lines 188:18-196:9 -/
@[reducible]
def chi.inner
  (res : StateArray) (a : StateArray) (x : Usize) : Result StateArray :=
  chi.inner_loop res a x 0#usize

/- [algos::chi]: loop 0:
   Source: 'src/algos.rs', lines 187:4-198:5 -/
def chi_loop
  (a : StateArray) (a1 : StateArray) (x : Usize) : Result StateArray :=
  if x < 5#usize
  then do
       let res ← chi.inner a1 a x
       let x1 ← x + 1#usize
       chi_loop a res x1
  else ok a1
partial_fixpoint

/- [algos::chi]:
   Source: 'src/algos.rs', lines 184:0-200:1 -/
@[reducible]
def chi (a : StateArray) : Result StateArray :=
  chi_loop a a 0#usize

/- [algos::IOTA_RC]
   Source: 'src/algos.rs', lines 202:0-202:508 -/
@[global_simps]
def IOTA_RC_body : Result (Array U64 24#usize) :=
  ok
    (Array.make 24#usize [
      1#u64, 32898#u64, 9223372036854808714#u64, 9223372039002292224#u64,
      32907#u64, 2147483649#u64, 9223372039002292353#u64,
      9223372036854808585#u64, 138#u64, 136#u64, 2147516425#u64,
      2147483658#u64, 2147516555#u64, 9223372036854775947#u64,
      9223372036854808713#u64, 9223372036854808579#u64,
      9223372036854808578#u64, 9223372036854775936#u64, 32778#u64,
      9223372039002259466#u64, 9223372039002292353#u64,
      9223372036854808704#u64, 2147483649#u64, 9223372039002292232#u64
      ])
@[global_simps, irreducible]
def IOTA_RC : Array U64 24#usize := eval_global IOTA_RC_body

/- [algos::iota]:
   Source: 'src/algos.rs', lines 204:0-208:1 -/
def iota (ir : Usize) (a : StateArray) : Result StateArray :=
  do
  let i ← IndexalgosStateArrayPairUsizeUsizeU64.index a (0#usize, 0#usize)
  let i1 ← Array.index_usize IOTA_RC ir
  let (_, index_mut_back) ←
    IndexMutalgosStateArrayPairUsizeUsizeU64.index_mut a (0#usize, 0#usize)
  let i2 ← (↑(i ^^^ i1) : Result U64)
  ok (index_mut_back i2)

/- [algos::round]:
   Source: 'src/algos.rs', lines 210:0-217:1 -/
def round (a : StateArray) (ir : Usize) : Result StateArray :=
  do
  let a1 ← theta a
  let a11 ← rho a1
  let a12 ← pi a11
  let a13 ← chi a12
  iota ir a13

/- [algos::keccak_p]: loop 0:
   Source: 'src/algos.rs', lines 221:4-224:5 -/
def keccak_p_loop (s : StateArray) (ir : Usize) : Result StateArray :=
  if ir < 24#usize
  then do
       let s1 ← round s ir
       let ir1 ← ir + 1#usize
       keccak_p_loop s1 ir1
  else ok s
partial_fixpoint

/- [algos::keccak_p]:
   Source: 'src/algos.rs', lines 219:0-225:1 -/
@[reducible]
def keccak_p (s : StateArray) : Result StateArray :=
  keccak_p_loop s 0#usize

/- [algos::sponge_absorb_initial]: loop 0:
   Source: 'src/algos.rs', lines 231:4-236:5 -/
def sponge_absorb_initial_loop
  (bs : Slice U8) (r : Usize) (s : StateArray) (n : Usize) (i : Usize) :
  Result StateArray
  :=
  if i < n
  then
    do
    let i1 ← r * i
    let i2 ← i + 1#usize
    let i3 ← r * i2
    let chunk ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeUsizeSliceInst U8) bs
        { start := i1, end_ := i3 }
    let s1 ← StateArray.xor s chunk
    let s2 ← keccak_p s1
    sponge_absorb_initial_loop bs r s2 n i2
  else ok s
partial_fixpoint

/- [algos::sponge_absorb_initial]:
   Source: 'src/algos.rs', lines 228:0-237:1 -/
def sponge_absorb_initial
  (bs : Slice U8) (r : Usize) (s : StateArray) : Result StateArray :=
  do
  let i := Slice.len bs
  let n ← i / r
  sponge_absorb_initial_loop bs r s n 0#usize

/- [algos::sponge_absorb_final]:
   Source: 'src/algos.rs', lines 240:0-253:1 -/
def sponge_absorb_final
  (s : StateArray) (rest : Slice U8) (extra : U8) (r : Usize) :
  Result StateArray
  :=
  do
  let s1 ← StateArray.xor s rest
  let i := Slice.len rest
  let s2 ← StateArray.xor_byte_at s1 extra i
  let i1 ← r - 1#usize
  let s3 ← StateArray.xor_byte_at s2 128#u8 i1
  keccak_p s3

/- [algos::sponge_absorb]:
   Source: 'src/algos.rs', lines 256:0-261:1 -/
def sponge_absorb
  (bs : Slice U8) (r : Usize) (s : StateArray) (extra : U8) :
  Result StateArray
  :=
  do
  let s1 ← sponge_absorb_initial bs r s
  let i := Slice.len bs
  let n ← i / r
  let i1 ← r * n
  let rest ←
    core.slice.index.Slice.index
      (core.slice.index.SliceIndexRangeFromUsizeSlice U8) bs { start := i1 }
  sponge_absorb_final s1 rest extra r

/- [algos::sponge_squeeze]: loop 0:
   Source: 'src/algos.rs', lines 267:4-276:5 -/
def sponge_squeeze_loop
  (r : Usize) (z : Slice U8) (s : StateArray) (i : Usize) (d : Usize) :
  Result (Slice U8)
  :=
  do
  let i1 ← i + r
  if i1 < d
  then
    do
    let (s1, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeUsizeSliceInst U8) z
        { start := i, end_ := i1 }
    let s2 ← StateArray.copy_to s s1
    let s3 ← keccak_p s
    let z1 := index_mut_back s2
    sponge_squeeze_loop r z1 s3 i1 d
  else
    do
    let (s1, index_mut_back) ←
      core.slice.index.Slice.index_mut
        (core.slice.index.SliceIndexRangeFromUsizeSlice U8) z { start := i }
    let s2 ← StateArray.copy_to s s1
    ok (index_mut_back s2)
partial_fixpoint

/- [algos::sponge_squeeze]:
   Source: 'src/algos.rs', lines 263:0-277:1 -/
def sponge_squeeze
  (r : Usize) (z : Slice U8) (s : StateArray) : Result (Slice U8) :=
  let d := Slice.len z
  sponge_squeeze_loop r z s 0#usize d

/- [algos::sponge]:
   Source: 'src/algos.rs', lines 280:0-284:1 -/
def sponge
  (r : Usize) (bs : Slice U8) (output : Slice U8) (extra : U8) :
  Result (Slice U8)
  :=
  do
  let s ← DefaultalgosStateArray.default
  let s1 ← sponge_absorb bs r s extra
  sponge_squeeze r output s1

/- [algos::SHA3_EXTRA]
   Source: 'src/algos.rs', lines 286:0-286:35 -/
@[global_simps] def SHA3_EXTRA_body : Result U8 := ok 6#u8
@[global_simps, irreducible] def SHA3_EXTRA : U8 := eval_global SHA3_EXTRA_body

/- [algos::sha3_224]:
   Source: 'src/algos.rs', lines 287:0-287:123 -/
def sha3_224 (bs : Slice U8) : Result (Array U8 28#usize) :=
  do
  let output := Array.repeat 28#usize 0#u8
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice U8) × (Slice U8 → Array
      U8 28#usize)))
  let s1 ← sponge 144#usize bs s SHA3_EXTRA
  ok (to_slice_mut_back s1)

/- [algos::sha3_256]:
   Source: 'src/algos.rs', lines 288:0-288:123 -/
def sha3_256 (bs : Slice U8) : Result (Array U8 32#usize) :=
  do
  let output := Array.repeat 32#usize 0#u8
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice U8) × (Slice U8 → Array
      U8 32#usize)))
  let s1 ← sponge 136#usize bs s SHA3_EXTRA
  ok (to_slice_mut_back s1)

/- [algos::sha3_384]:
   Source: 'src/algos.rs', lines 289:0-289:123 -/
def sha3_384 (bs : Slice U8) : Result (Array U8 48#usize) :=
  do
  let output := Array.repeat 48#usize 0#u8
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice U8) × (Slice U8 → Array
      U8 48#usize)))
  let s1 ← sponge 104#usize bs s SHA3_EXTRA
  ok (to_slice_mut_back s1)

/- [algos::sha3_512]:
   Source: 'src/algos.rs', lines 290:0-290:122 -/
def sha3_512 (bs : Slice U8) : Result (Array U8 64#usize) :=
  do
  let output := Array.repeat 64#usize 0#u8
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice U8) × (Slice U8 → Array
      U8 64#usize)))
  let s1 ← sponge 72#usize bs s SHA3_EXTRA
  ok (to_slice_mut_back s1)

/- [algos::SHAKE_EXTRA]
   Source: 'src/algos.rs', lines 292:0-292:35 -/
@[global_simps] def SHAKE_EXTRA_body : Result U8 := ok 31#u8
@[global_simps, irreducible]
def SHAKE_EXTRA : U8 := eval_global SHAKE_EXTRA_body

/- [algos::shake128]:
   Source: 'src/algos.rs', lines 293:0-293:87 -/
def shake128 (bs : Slice U8) (output : Slice U8) : Result (Slice U8) :=
  sponge 168#usize bs output SHAKE_EXTRA

/- [algos::shake256]:
   Source: 'src/algos.rs', lines 294:0-294:87 -/
def shake256 (bs : Slice U8) (output : Slice U8) : Result (Slice U8) :=
  sponge 136#usize bs output SHAKE_EXTRA

end algos
