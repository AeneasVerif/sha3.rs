-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [simple]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace simple

/- [simple::L]
   Source: 'src/simple.rs', lines 3:0-3:20 -/
@[global_simps] def L_body : Result Usize := ok 6#usize
@[global_simps, irreducible] def L : Usize := eval_global L_body

/- [simple::W]
   Source: 'src/simple.rs', lines 4:0-4:23 -/
@[global_simps] def W_body : Result Usize := 1#usize <<< L
@[global_simps, irreducible] def W : Usize := eval_global W_body

/- [simple::B]
   Source: 'src/simple.rs', lines 5:0-5:24 -/
@[global_simps]
def B_body : Result Usize := do
                             let i ← 5#usize * 5#usize
                             i * W
@[global_simps, irreducible] def B : Usize := eval_global B_body

/- [simple::NR]
   Source: 'src/simple.rs', lines 6:0-6:21 -/
@[global_simps] def NR_body : Result Usize := ok 24#usize
@[global_simps, irreducible] def NR : Usize := eval_global NR_body

/- [simple::add_to_vec]: loop 0:
   Source: 'src/simple.rs', lines 1:0-13:5 -/
def add_to_vec_loop
  {A : Type} (coremarkerCopyInst : core.marker.Copy A) (dst : Slice A)
  (o : Usize) (src : Slice A) (n : Usize) (i : Usize) :
  Result (Usize × (Slice A))
  :=
  if i < n
  then
    do
    let i1 ← o + i
    let i2 := Slice.len dst
    if i1 < i2
    then
      do
      let t ← Slice.index_usize src i
      let dst1 ← Slice.update dst i1 t
      let i3 ← i + 1#usize
      add_to_vec_loop coremarkerCopyInst dst1 o src n i3
    else ok (i, dst)
  else ok (i, dst)
partial_fixpoint

/- [simple::add_to_vec]:
   Source: 'src/simple.rs', lines 8:0-15:1 -/
@[reducible]
def add_to_vec
  {A : Type} (coremarkerCopyInst : core.marker.Copy A) (dst : Slice A)
  (o : Usize) (src : Slice A) (n : Usize) :
  Result (Usize × (Slice A))
  :=
  add_to_vec_loop coremarkerCopyInst dst o src n 0#usize

/- [simple::binxor]:
   Source: 'src/simple.rs', lines 17:0-19:1 -/
def binxor (a : Bool) (b : Bool) : Result Bool :=
  if a
  then if b
       then ok (¬ true)
       else ok true
  else if b
       then ok (¬ false)
       else ok false

/- [simple::xor_long]: loop 0:
   Source: 'src/simple.rs', lines 25:4-28:5 -/
def xor_long_loop
  (s : Slice Bool) (other : Slice Bool) (n : Usize) (i : Usize) :
  Result (Slice Bool)
  :=
  if i < n
  then
    do
    let b ← Slice.index_usize s i
    let b1 ← Slice.index_usize other i
    let b2 ← binxor b b1
    let s1 ← Slice.update s i b2
    let i1 ← i + 1#usize
    xor_long_loop s1 other n i1
  else ok s
partial_fixpoint

/- [simple::xor_long]:
   Source: 'src/simple.rs', lines 21:0-29:1 -/
def xor_long (s : Slice Bool) (other : Slice Bool) : Result (Slice Bool) :=
  do
  let i := Slice.len s
  let i1 := Slice.len other
  let n ← (↑(core.cmp.impls.OrdUsize.min i i1) : Result Usize)
  xor_long_loop s other n 0#usize

/- [simple::xor_long_at]: loop 0:
   Source: 'src/simple.rs', lines 34:4-37:5 -/
def xor_long_at_loop
  (s : Slice Bool) (other : Slice Bool) (pos : Usize) (n : Usize)
  (pos1 : Usize) :
  Result (Slice Bool)
  :=
  if pos1 < n
  then
    do
    let b ← Slice.index_usize s pos1
    let i ← pos1 - pos
    let b1 ← Slice.index_usize other i
    let b2 ← binxor b b1
    let s1 ← Slice.update s pos1 b2
    let i1 ← pos1 + 1#usize
    xor_long_at_loop s1 other pos n i1
  else ok s
partial_fixpoint

/- [simple::xor_long_at]:
   Source: 'src/simple.rs', lines 30:0-38:1 -/
def xor_long_at
  (s : Slice Bool) (other : Slice Bool) (pos : Usize) : Result (Slice Bool) :=
  do
  let i := Slice.len s
  let i1 := Slice.len other
  let n ← (↑(core.cmp.impls.OrdUsize.min i i1) : Result Usize)
  xor_long_at_loop s other pos n pos

/- [simple::StateArray]
   Source: 'src/simple.rs', lines 40:0-40:29 -/
@[reducible] def StateArray := (Array Bool 1600#usize)

/- Trait declaration: [core::default::Default]
   Source: '/rustc/library/core/src/default.rs', lines 107:0-107:24
   Name pattern: core::default::Default -/
structure core.default.Default (Self : Type) where
  default : Result Self

/- [simple::{core::default::Default for simple::StateArray}::default]:
   Source: 'src/simple.rs', lines 43:4-45:5 -/
def DefaultsimpleStateArray.default : Result StateArray :=
  let a := Array.repeat 1600#usize false
  ok a

/- Trait implementation: [simple::{core::default::Default for simple::StateArray}]
   Source: 'src/simple.rs', lines 42:0-46:1 -/
@[reducible]
def core.default.DefaultsimpleStateArray : core.default.Default StateArray := {
  default := DefaultsimpleStateArray.default
}

/- [simple::{core::clone::Clone for simple::StateArray}#1::clone]:
   Source: 'src/simple.rs', lines 49:4-51:5 -/
def ClonesimpleStateArray.clone (self : StateArray) : Result StateArray :=
  ok self

/- Trait implementation: [simple::{core::clone::Clone for simple::StateArray}#1]
   Source: 'src/simple.rs', lines 48:0-52:1 -/
@[reducible]
def core.clone.ClonesimpleStateArray : core.clone.Clone StateArray := {
  clone := ClonesimpleStateArray.clone
}

/- [simple::{simple::StateArray}#2::index]:
   Source: 'src/simple.rs', lines 55:4-58:5 -/
def StateArray.index
  (self : StateArray) (index : (U8 × U8 × Usize)) : Result Bool :=
  do
  let (x, y, z) := index
  let i ← (↑(UScalar.cast .Usize y) : Result Usize)
  let i1 ← 5#usize * i
  let i2 ← (↑(UScalar.cast .Usize x) : Result Usize)
  let i3 ← i1 + i2
  let i4 ← W * i3
  let i5 ← i4 + z
  Array.index_usize self i5

/- [simple::{simple::StateArray}#2::index_mut]:
   Source: 'src/simple.rs', lines 60:4-63:5 -/
def StateArray.index_mut
  (self : StateArray) (index : (U8 × U8 × Usize)) :
  Result (Bool × (Bool → StateArray))
  :=
  do
  let (x, y, z) := index
  let i ← (↑(UScalar.cast .Usize y) : Result Usize)
  let i1 ← 5#usize * i
  let i2 ← (↑(UScalar.cast .Usize x) : Result Usize)
  let i3 ← i1 + i2
  let i4 ← W * i3
  let i5 ← i4 + z
  let (b, index_mut_back) ← Array.index_mut_usize self i5
  let back := fun ret => let a := index_mut_back ret
                         a
  ok (b, back)

/- [simple::theta::theta_c]:
   Source: 'src/simple.rs', lines 67:4-81:5 -/
def theta.theta_c (a : StateArray) (x : U8) (z : Usize) : Result Bool :=
  do
  let b ← StateArray.index a (x, 0#u8, z)
  let b1 ← StateArray.index a (x, 1#u8, z)
  let b2 ← StateArray.index a (x, 2#u8, z)
  let b3 ← StateArray.index a (x, 3#u8, z)
  let b4 ← StateArray.index a (x, 4#u8, z)
  let b5 ← binxor b3 b4
  let b6 ← binxor b2 b5
  let b7 ← binxor b1 b6
  binxor b b7

/- [simple::theta::theta_d]:
   Source: 'src/simple.rs', lines 82:4-87:5 -/
def theta.theta_d (a : StateArray) (x : U8) (z : Usize) : Result Bool :=
  do
  let i ← x + 4#u8
  let x1 ← i % 5#u8
  let i1 ← x + 1#u8
  let x2 ← i1 % 5#u8
  let i2 ← W - 1#usize
  let i3 ← z + i2
  let z2 ← i3 % W
  let b ← theta.theta_c a x1 z
  let b1 ← theta.theta_c a x2 z2
  binxor b b1

/- [simple::theta::theta_apply_a_inner::theta_apply_a_inner2]: loop 0:
   Source: 'src/simple.rs', lines 97:20-100:21 -/
def theta.theta_apply_a_inner.theta_apply_a_inner2_loop
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let b ← StateArray.index a (x, y, z)
    let b1 ← theta.theta_d a x z
    let b2 ← binxor b b1
    let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b2
    theta.theta_apply_a_inner.theta_apply_a_inner2_loop res1 a x y z1
  else ok res
partial_fixpoint

/- [simple::theta::theta_apply_a_inner::theta_apply_a_inner2]:
   Source: 'src/simple.rs', lines 95:26-101:17 -/
@[reducible]
def theta.theta_apply_a_inner.theta_apply_a_inner2
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) : Result StateArray :=
  theta.theta_apply_a_inner.theta_apply_a_inner2_loop res a x y 0#usize

/- [simple::theta::theta_apply_a_inner]: loop 0:
   Source: 'src/simple.rs', lines 94:12-103:13 -/
def theta.theta_apply_a_inner_loop
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) : Result StateArray :=
  if y < 5#u8
  then
    do
    let res1 ← theta.theta_apply_a_inner.theta_apply_a_inner2 res a x y
    let y1 ← y + 1#u8
    theta.theta_apply_a_inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [simple::theta::theta_apply_a_inner]:
   Source: 'src/simple.rs', lines 91:18-104:9 -/
@[reducible]
def theta.theta_apply_a_inner
  (res : StateArray) (a : StateArray) (x : U8) : Result StateArray :=
  theta.theta_apply_a_inner_loop res a x 0#u8

/- [simple::theta]: loop 0:
   Source: 'src/simple.rs', lines 90:4-106:5 -/
def theta_loop
  (a : StateArray) (res : StateArray) (x : U8) : Result StateArray :=
  if x < 5#u8
  then
    do
    let res1 ← theta.theta_apply_a_inner res a x
    let x1 ← x + 1#u8
    theta_loop a res1 x1
  else ok res
partial_fixpoint

/- [simple::theta]:
   Source: 'src/simple.rs', lines 66:0-108:1 -/
def theta (a : StateArray) : Result StateArray :=
  do
  let res ← DefaultsimpleStateArray.default
  theta_loop a res 0#u8

/- [simple::rho_offset]:
   Source: 'src/simple.rs', lines 110:0-112:1 -/
def rho_offset (t : Usize) : Result Usize :=
  do
  let i ← t + 1#usize
  let i1 ← t + 2#usize
  let i2 ← i * i1
  let i3 ← i2 / 2#usize
  i3 % W

/- [simple::rho::rho_inner]: loop 0:
   Source: 'src/simple.rs', lines 121:12-125:13 -/
def rho.rho_inner_loop
  (res : StateArray) (a : StateArray) (t : Usize) (x : U8) (y : U8) (z : Usize)
  :
  Result StateArray
  :=
  if z < W
  then
    do
    let i ← rho_offset t
    let i1 ← W - i
    let i2 ← z + i1
    let z2 ← i2 % W
    let b ← StateArray.index a (x, y, z2)
    let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b
    rho.rho_inner_loop res1 a t x y z1
  else ok res
partial_fixpoint

/- [simple::rho::rho_inner]:
   Source: 'src/simple.rs', lines 119:8-126:9 -/
@[reducible]
def rho.rho_inner
  (res : StateArray) (a : StateArray) (t : Usize) (x : U8) (y : U8) :
  Result StateArray
  :=
  rho.rho_inner_loop res a t x y 0#usize

/- [simple::rho]: loop 0:
   Source: 'src/simple.rs', lines 117:4-130:5 -/
def rho_loop
  (a : StateArray) (x : U8) (y : U8) (res : StateArray) (t : Usize) :
  Result StateArray
  :=
  if t < 24#usize
  then
    do
    let res1 ← rho.rho_inner res a t x y
    let i ← 2#u8 * x
    let i1 ← 3#u8 * y
    let i2 ← i + i1
    let lhs ← i2 % 5#u8
    let t1 ← t + 1#usize
    rho_loop a y lhs res1 t1
  else ok res
partial_fixpoint

/- [simple::rho]:
   Source: 'src/simple.rs', lines 113:0-132:1 -/
def rho (a : StateArray) : Result StateArray :=
  do
  let res ← ClonesimpleStateArray.clone a
  rho_loop a 1#u8 0#u8 res 0#usize

/- [simple::pi::pi_inner::pi_inner2]: loop 0:
   Source: 'src/simple.rs', lines 145:20-150:21 -/
def pi.pi_inner.pi_inner2_loop
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let i ← 3#u8 * y
    let i1 ← x + i
    let x2 ← i1 % 5#u8
    let b ← StateArray.index a (x2, x, z)
    let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b
    pi.pi_inner.pi_inner2_loop res1 a x y z1
  else ok res
partial_fixpoint

/- [simple::pi::pi_inner::pi_inner2]:
   Source: 'src/simple.rs', lines 143:16-151:17 -/
@[reducible]
def pi.pi_inner.pi_inner2
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) : Result StateArray :=
  pi.pi_inner.pi_inner2_loop res a x y 0#usize

/- [simple::pi::pi_inner]: loop 0:
   Source: 'src/simple.rs', lines 141:12-154:13 -/
def pi.pi_inner_loop
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) : Result StateArray :=
  if y < 5#u8
  then
    do
    let res1 ← pi.pi_inner.pi_inner2 res a x y
    let y1 ← y + 1#u8
    pi.pi_inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [simple::pi::pi_inner]:
   Source: 'src/simple.rs', lines 139:8-155:9 -/
@[reducible]
def pi.pi_inner
  (res : StateArray) (a : StateArray) (x : U8) : Result StateArray :=
  pi.pi_inner_loop res a x 0#u8

/- [simple::pi]: loop 0:
   Source: 'src/simple.rs', lines 137:4-158:5 -/
def pi_loop (a : StateArray) (res : StateArray) (x : U8) : Result StateArray :=
  if x < 5#u8
  then
    do
    let res1 ← pi.pi_inner res a x
    let x1 ← x + 1#u8
    pi_loop a res1 x1
  else ok res
partial_fixpoint

/- [simple::pi]:
   Source: 'src/simple.rs', lines 134:0-160:1 -/
def pi (a : StateArray) : Result StateArray :=
  do
  let res ← ClonesimpleStateArray.clone a
  pi_loop a res 0#u8

/- [simple::chi::chi_inner::chi_inner2]: loop 0:
   Source: 'src/simple.rs', lines 173:20-179:21 -/
def chi.chi_inner.chi_inner2_loop
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let i ← x + 1#u8
    let x1 ← i % 5#u8
    let i1 ← x + 2#u8
    let x2 ← i1 % 5#u8
    let b ← StateArray.index a (x, y, z)
    let b1 ← StateArray.index a (x1, y, z)
    let b2 ← binxor b1 true
    if b2
    then
      do
      let b3 ← StateArray.index a (x2, y, z)
      let b4 ← binxor b b3
      let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
      let z1 ← z + 1#usize
      let res1 := index_mut_back b4
      chi.chi_inner.chi_inner2_loop res1 a x y z1
    else
      do
      let b3 ← binxor b false
      let (_, index_mut_back) ← StateArray.index_mut res (x, y, z)
      let z1 ← z + 1#usize
      let res1 := index_mut_back b3
      chi.chi_inner.chi_inner2_loop res1 a x y z1
  else ok res
partial_fixpoint

/- [simple::chi::chi_inner::chi_inner2]:
   Source: 'src/simple.rs', lines 171:16-180:17 -/
@[reducible]
def chi.chi_inner.chi_inner2
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) : Result StateArray :=
  chi.chi_inner.chi_inner2_loop res a x y 0#usize

/- [simple::chi::chi_inner]: loop 0:
   Source: 'src/simple.rs', lines 169:12-183:13 -/
def chi.chi_inner_loop
  (res : StateArray) (a : StateArray) (x : U8) (y : U8) : Result StateArray :=
  if y < 5#u8
  then
    do
    let res1 ← chi.chi_inner.chi_inner2 res a x y
    let y1 ← y + 1#u8
    chi.chi_inner_loop res1 a x y1
  else ok res
partial_fixpoint

/- [simple::chi::chi_inner]:
   Source: 'src/simple.rs', lines 167:8-184:9 -/
@[reducible]
def chi.chi_inner
  (res : StateArray) (a : StateArray) (x : U8) : Result StateArray :=
  chi.chi_inner_loop res a x 0#u8

/- [simple::chi]: loop 0:
   Source: 'src/simple.rs', lines 165:4-187:5 -/
def chi_loop
  (a : StateArray) (res : StateArray) (x : U8) : Result StateArray :=
  if x < 5#u8
  then
    do
    let res1 ← chi.chi_inner res a x
    let x1 ← x + 1#u8
    chi_loop a res1 x1
  else ok res
partial_fixpoint

/- [simple::chi]:
   Source: 'src/simple.rs', lines 162:0-189:1 -/
def chi (a : StateArray) : Result StateArray :=
  do
  let res ← ClonesimpleStateArray.clone a
  chi_loop a res 0#u8

/- [simple::IOTA_RC_POINTS]
   Source: 'src/simple.rs', lines 192:0-206:15 -/
@[global_simps]
def IOTA_RC_POINTS_body : Result (Array Bool 255#usize) :=
  ok
  (Array.make 255#usize [
    true, false, false, false, false, false, false, false, true, false, true,
    true, false, false, false, true, true, true, true, false, true, false,
    false, false, false, true, true, true, true, true, true, true, true, false,
    false, true, false, false, false, false, true, false, true, false, false,
    true, true, true, true, true, false, true, false, true, false, true, false,
    true, true, true, false, false, false, false, false, true, true, false,
    false, false, true, false, true, false, true, true, false, false, true,
    true, false, false, true, false, true, true, true, true, true, true, false,
    true, true, true, true, false, false, true, true, false, true, true, true,
    false, true, true, true, false, false, true, false, true, false, true,
    false, false, true, false, true, false, false, false, true, false, false,
    true, false, true, true, false, true, false, false, false, true, true,
    false, false, true, true, true, false, false, true, true, true, true,
    false, false, false, true, true, false, true, true, false, false, false,
    false, true, false, false, false, true, false, true, true, true, false,
    true, false, true, true, true, true, false, true, true, false, true, true,
    true, true, true, false, false, false, false, true, true, false, true,
    false, false, true, true, false, true, false, true, true, false, true,
    true, false, true, false, true, false, false, false, false, false, true,
    false, false, true, true, true, false, true, true, false, false, true,
    false, false, true, false, false, true, true, false, false, false, false,
    false, false, true, true, true, false, true, false, false, true, false,
    false, false, true, true, true, false, false, false
    ])
@[global_simps, irreducible]
def IOTA_RC_POINTS : Array Bool 255#usize := eval_global IOTA_RC_POINTS_body

/- [simple::iota_rc_point]:
   Source: 'src/simple.rs', lines 208:0-212:1 -/
def iota_rc_point (t : Usize) : Result Bool :=
  do
  let t1 ← t % 255#usize
  Array.index_usize IOTA_RC_POINTS t1

/- [simple::iota_rc_init]: loop 0:
   Source: 'src/simple.rs', lines 216:4-219:5 -/
def iota_rc_init_loop
  (ir : Usize) (rc : Array Bool 64#usize) (j : Usize) :
  Result (Array Bool 64#usize)
  :=
  if j <= L
  then
    do
    let i ← 7#usize * ir
    let i1 ← j + i
    let b ← iota_rc_point i1
    let i2 ← 1#usize <<< j
    let i3 ← i2 - 1#usize
    let rc1 ← Array.update rc i3 b
    let j1 ← j + 1#usize
    iota_rc_init_loop ir rc1 j1
  else ok rc
partial_fixpoint

/- [simple::iota_rc_init]:
   Source: 'src/simple.rs', lines 214:0-220:1 -/
@[reducible]
def iota_rc_init
  (ir : Usize) (rc : Array Bool 64#usize) : Result (Array Bool 64#usize) :=
  iota_rc_init_loop ir rc 0#usize

/- [simple::iota_a]: loop 0:
   Source: 'src/simple.rs', lines 224:4-227:5 -/
def iota_a_loop
  (res : StateArray) (a : StateArray) (rc : Array Bool 64#usize) (z : Usize) :
  Result StateArray
  :=
  if z < W
  then
    do
    let b ← StateArray.index a (0#u8, 0#u8, z)
    let b1 ← Array.index_usize rc z
    let b2 ← binxor b b1
    let (_, index_mut_back) ← StateArray.index_mut res (0#u8, 0#u8, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b2
    iota_a_loop res1 a rc z1
  else ok res
partial_fixpoint

/- [simple::iota_a]:
   Source: 'src/simple.rs', lines 222:0-228:1 -/
@[reducible]
def iota_a
  (res : StateArray) (a : StateArray) (rc : Array Bool 64#usize) :
  Result StateArray
  :=
  iota_a_loop res a rc 0#usize

/- [simple::iota]:
   Source: 'src/simple.rs', lines 230:0-236:1 -/
def iota (ir : Usize) (a : StateArray) : Result StateArray :=
  do
  let rc := Array.repeat 64#usize false
  let rc1 ← iota_rc_init ir rc
  let res ← ClonesimpleStateArray.clone a
  iota_a res a rc1

/- [simple::round]:
   Source: 'src/simple.rs', lines 238:0-244:1 -/
def round (a : StateArray) (ir : Usize) : Result StateArray :=
  do
  let a1 ← theta a
  let a2 ← rho a1
  let a3 ← pi a2
  let a4 ← chi a3
  iota ir a4

/- [simple::keccak_p]: loop 0:
   Source: 'src/simple.rs', lines 249:4-252:5 -/
def keccak_p_loop (a : StateArray) (ir : Usize) : Result Unit :=
  if ir < 24#usize
  then do
       let a1 ← round a ir
       let ir1 ← ir + 1#usize
       keccak_p_loop a1 ir1
  else ok ()
partial_fixpoint

/- [simple::keccak_p]:
   Source: 'src/simple.rs', lines 246:0-254:1 -/
def keccak_p (s : Array Bool 1600#usize) : Result (Array Bool 1600#usize) :=
  do
  keccak_p_loop s 0#usize
  ok s

/- [simple::sponge_absorb]: loop 0:
   Source: 'src/simple.rs', lines 272:4-277:5 -/
def sponge_absorb_loop
  (bs : Slice Bool) (r : Usize) (s : Array Bool 1600#usize)
  (suffix : Slice Bool) (n : Usize) (i : Usize) :
  Result (Array Bool 1600#usize)
  :=
  if i < n
  then
    do
    let i1 ← r * i
    let i2 ← i + 1#usize
    let i3 ← r * i2
    let chunk ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeUsizeSliceInst Bool) bs
        { start := i1, end_ := i3 }
    let (s1, to_slice_mut_back) ←
      (↑(Array.to_slice_mut s) : Result ((Slice Bool) × (Slice Bool →
         Array Bool 1600#usize)))
    let s2 ← xor_long s1 chunk
    let s3 := to_slice_mut_back s2
    let s4 ← keccak_p s3
    sponge_absorb_loop bs r s4 suffix n i2
  else
    do
    let i1 ← r * n
    let rest ←
      core.slice.index.Slice.index
        (core.slice.index.SliceIndexRangeFromUsizeSlice Bool) bs
        { start := i1 }
    let (s1, to_slice_mut_back) ←
      (↑(Array.to_slice_mut s) : Result ((Slice Bool) × (Slice Bool →
         Array Bool 1600#usize)))
    let s2 ← xor_long s1 rest
    let s3 := to_slice_mut_back s2
    let (s4, to_slice_mut_back1) ←
      (↑(Array.to_slice_mut s3) : Result ((Slice Bool) × (Slice Bool →
         Array Bool 1600#usize)))
    let i2 := Slice.len rest
    let s5 ← xor_long_at s4 suffix i2
    let i3 := Slice.len rest
    let i4 := Slice.len suffix
    let i5 ← i3 + i4
    let leftover ← (↑(core.num.Usize.saturating_sub i5 r) : Result Usize)
    if leftover > 0#usize
    then
      do
      let s6 := to_slice_mut_back1 s5
      let s7 ← keccak_p s6
      let (s8, to_slice_mut_back2) ←
        (↑(Array.to_slice_mut s7) : Result ((Slice Bool) × (Slice Bool →
           Array Bool 1600#usize)))
      let s9 ←
        core.slice.index.Slice.index
          (core.slice.index.SliceIndexRangeFromUsizeSlice Bool) suffix
          { start := leftover }
      let s10 ← xor_long s8 s9
      let s11 := to_slice_mut_back2 s10
      let (s12, to_slice_mut_back3) ←
        (↑(Array.to_slice_mut s11) : Result ((Slice Bool) × (Slice Bool →
           Array Bool 1600#usize)))
      let s13 ←
        (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice
           Bool))
      let i6 := Slice.len suffix
      let i7 ← i6 - leftover
      let s14 ← xor_long_at s12 s13 i7
      let s15 := to_slice_mut_back3 s14
      let (s16, to_slice_mut_back4) ←
        (↑(Array.to_slice_mut s15) : Result ((Slice Bool) × (Slice Bool →
           Array Bool 1600#usize)))
      let s17 ←
        (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice
           Bool))
      let i8 ← r - 1#usize
      let s18 ← xor_long_at s16 s17 i8
      let s19 := to_slice_mut_back4 s18
      keccak_p s19
    else
      do
      let s6 := to_slice_mut_back1 s5
      let (s7, to_slice_mut_back2) ←
        (↑(Array.to_slice_mut s6) : Result ((Slice Bool) × (Slice Bool →
           Array Bool 1600#usize)))
      let s8 ←
        (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice
           Bool))
      let i6 := Slice.len rest
      let i7 := Slice.len suffix
      let i8 ← i6 + i7
      let s9 ← xor_long_at s7 s8 i8
      let i9 := Slice.len rest
      let i10 ← i9 + 1#usize
      if i10 < r
      then
        do
        let s10 := to_slice_mut_back2 s9
        let (s11, to_slice_mut_back3) ←
          (↑(Array.to_slice_mut s10) : Result ((Slice Bool) × (Slice Bool
             → Array Bool 1600#usize)))
        let s12 ←
          (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice
             Bool))
        let i11 ← r - 1#usize
        let s13 ← xor_long_at s11 s12 i11
        let s14 := to_slice_mut_back3 s13
        keccak_p s14
      else
        do
        let s10 := to_slice_mut_back2 s9
        let s11 ← keccak_p s10
        let (s12, to_slice_mut_back3) ←
          (↑(Array.to_slice_mut s11) : Result ((Slice Bool) × (Slice Bool
             → Array Bool 1600#usize)))
        let s13 ←
          (↑(Array.to_slice (Array.make 1#usize [ true ])) : Result (Slice
             Bool))
        let i11 ← r - 1#usize
        let s14 ← xor_long_at s12 s13 i11
        let s15 := to_slice_mut_back3 s14
        keccak_p s15
partial_fixpoint

/- [simple::sponge_absorb]:
   Source: 'src/simple.rs', lines 269:0-297:1 -/
def sponge_absorb
  (bs : Slice Bool) (r : Usize) (s : Array Bool 1600#usize)
  (suffix : Slice Bool) :
  Result (Array Bool 1600#usize)
  :=
  do
  let i := Slice.len bs
  let n ← i / r
  sponge_absorb_loop bs r s suffix n 0#usize

/- Trait implementation: [core::marker::{core::marker::Copy for bool}#53]
   Source: '/rustc/library/core/src/marker.rs', lines 48:25-48:62
   Name pattern: core::marker::Copy<bool> -/
@[reducible]
def core.marker.CopyBool : core.marker.Copy Bool := {
  cloneInst := core.clone.CloneBool
}

/- [simple::sponge_squeeze]: loop 0:
   Source: 'src/simple.rs', lines 303:4-312:5 -/
def sponge_squeeze_loop
  (r : Usize) (z : Slice Bool) (s : Array Bool 1600#usize) (i : Usize) :
  Result (Slice Bool)
  :=
  do
  let s1 ← (↑(Array.to_slice s) : Result (Slice Bool))
  let (added, z1) ← add_to_vec core.marker.CopyBool z i s1 r
  let i1 ← i + added
  let i2 := Slice.len z1
  if i2 <= i1
  then ok z1
  else do
       let s2 ← keccak_p s
       sponge_squeeze_loop r z1 s2 i1
partial_fixpoint

/- [simple::sponge_squeeze]:
   Source: 'src/simple.rs', lines 300:0-313:1 -/
@[reducible]
def sponge_squeeze
  (r : Usize) (z : Slice Bool) (s : Array Bool 1600#usize) :
  Result (Slice Bool)
  :=
  sponge_squeeze_loop r z s 0#usize

/- [simple::sponge]:
   Source: 'src/simple.rs', lines 315:0-319:1 -/
def sponge
  (r : Usize) (bs : Slice Bool) (output : Slice Bool) (suffix : Slice Bool) :
  Result (Slice Bool)
  :=
  do
  let s := Array.repeat 1600#usize false
  let s1 ← sponge_absorb bs r s suffix
  sponge_squeeze r output s1

/- [simple::SHA3_SUFFIX]
   Source: 'src/simple.rs', lines 321:0-321:45 -/
@[global_simps]
def SHA3_SUFFIX_body : Result (Array Bool 2#usize) :=
  ok (Array.make 2#usize [ false, true ])
@[global_simps, irreducible]
def SHA3_SUFFIX : Array Bool 2#usize := eval_global SHA3_SUFFIX_body

/- [simple::sha3_224]:
   Source: 'src/simple.rs', lines 322:0-322:141 -/
def sha3_224 (bs : Slice Bool) : Result (Array Bool 224#usize) :=
  do
  let output := Array.repeat 224#usize false
  let i ← 2#usize * 224#usize
  let i1 ← B - i
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice Bool) × (Slice Bool →
       Array Bool 224#usize)))
  let s1 ← (↑(Array.to_slice SHA3_SUFFIX) : Result (Slice Bool))
  let s2 ← sponge i1 bs s s1
  ok (to_slice_mut_back s2)

/- [simple::sha3_256]:
   Source: 'src/simple.rs', lines 323:0-323:141 -/
def sha3_256 (bs : Slice Bool) : Result (Array Bool 256#usize) :=
  do
  let output := Array.repeat 256#usize false
  let i ← 2#usize * 256#usize
  let i1 ← B - i
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice Bool) × (Slice Bool →
       Array Bool 256#usize)))
  let s1 ← (↑(Array.to_slice SHA3_SUFFIX) : Result (Slice Bool))
  let s2 ← sponge i1 bs s s1
  ok (to_slice_mut_back s2)

/- [simple::sha3_384]:
   Source: 'src/simple.rs', lines 324:0-324:141 -/
def sha3_384 (bs : Slice Bool) : Result (Array Bool 384#usize) :=
  do
  let output := Array.repeat 384#usize false
  let i ← 2#usize * 384#usize
  let i1 ← B - i
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice Bool) × (Slice Bool →
       Array Bool 384#usize)))
  let s1 ← (↑(Array.to_slice SHA3_SUFFIX) : Result (Slice Bool))
  let s2 ← sponge i1 bs s s1
  ok (to_slice_mut_back s2)

/- [simple::sha3_512]:
   Source: 'src/simple.rs', lines 325:0-325:141 -/
def sha3_512 (bs : Slice Bool) : Result (Array Bool 512#usize) :=
  do
  let output := Array.repeat 512#usize false
  let i ← 2#usize * 512#usize
  let i1 ← B - i
  let (s, to_slice_mut_back) ←
    (↑(Array.to_slice_mut output) : Result ((Slice Bool) × (Slice Bool →
       Array Bool 512#usize)))
  let s1 ← (↑(Array.to_slice SHA3_SUFFIX) : Result (Slice Bool))
  let s2 ← sponge i1 bs s s1
  ok (to_slice_mut_back s2)

/- [simple::SHAKE_SUFFIX]
   Source: 'src/simple.rs', lines 327:0-327:42 -/
@[global_simps]
def SHAKE_SUFFIX_body : Result (Array Bool 4#usize) :=
  ok (Array.repeat 4#usize true)
@[global_simps, irreducible]
def SHAKE_SUFFIX : Array Bool 4#usize := eval_global SHAKE_SUFFIX_body

/- [simple::shake128]:
   Source: 'src/simple.rs', lines 328:0-328:99 -/
def shake128 (bs : Slice Bool) (output : Slice Bool) : Result (Slice Bool) :=
  do
  let i ← 2#usize * 128#usize
  let i1 ← B - i
  let s ← (↑(Array.to_slice SHAKE_SUFFIX) : Result (Slice Bool))
  sponge i1 bs output s

/- [simple::shake256]:
   Source: 'src/simple.rs', lines 329:0-329:99 -/
def shake256 (bs : Slice Bool) (output : Slice Bool) : Result (Slice Bool) :=
  do
  let i ← 2#usize * 256#usize
  let i1 ← B - i
  let s ← (↑(Array.to_slice SHAKE_SUFFIX) : Result (Slice Bool))
  sponge i1 bs output s

end simple
