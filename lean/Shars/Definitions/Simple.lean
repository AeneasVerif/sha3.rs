-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [sha3]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace sha3

/- [sha3::simple::L]
   Source: 'src/simple.rs', lines 3:0-3:20 -/
@[global_simps] def simple.L_body : Result Usize := ok 6#usize
@[global_simps, irreducible] def simple.L : Usize := eval_global simple.L_body

/- [sha3::simple::W]
   Source: 'src/simple.rs', lines 4:0-4:23 -/
@[global_simps] def simple.W_body : Result Usize := 1#usize <<< simple.L
@[global_simps, irreducible] def simple.W : Usize := eval_global simple.W_body

/- [sha3::simple::B]
   Source: 'src/simple.rs', lines 5:0-5:24 -/
@[global_simps]
def simple.B_body : Result Usize := do
                                    let i ← 5#usize * 5#usize
                                    i * simple.W
@[global_simps, irreducible] def simple.B : Usize := eval_global simple.B_body

/- [sha3::simple::NR]
   Source: 'src/simple.rs', lines 6:0-6:21 -/
@[global_simps] def simple.NR_body : Result Usize := ok 24#usize
@[global_simps, irreducible]
def simple.NR : Usize := eval_global simple.NR_body

/- [sha3::simple::add_to_vec]: loop 0:
   Source: 'src/simple.rs', lines 10:4-13:5 -/
divergent def simple.add_to_vec_loop
  {A : Type} (coremarkerCopyInst : core.marker.Copy A) (dst : alloc.vec.Vec A)
  (src : Slice A) (n : Usize) (i : Usize) :
  Result (alloc.vec.Vec A)
  :=
  if i < n
  then
    do
    let t ← Slice.index_usize src i
    let dst1 ← alloc.vec.Vec.push dst t
    let i1 ← i + 1#usize
    simple.add_to_vec_loop coremarkerCopyInst dst1 src n i1
  else ok dst

/- [sha3::simple::add_to_vec]:
   Source: 'src/simple.rs', lines 8:0-14:1 -/
@[reducible]
def simple.add_to_vec
  {A : Type} (coremarkerCopyInst : core.marker.Copy A) (dst : alloc.vec.Vec A)
  (src : Slice A) (n : Usize) :
  Result (alloc.vec.Vec A)
  :=
  simple.add_to_vec_loop coremarkerCopyInst dst src n 0#usize

/- [sha3::simple::binxor]:
   Source: 'src/simple.rs', lines 16:0-18:1 -/
def simple.binxor (a : Bool) (b : Bool) : Result Bool :=
  if a
  then if b
       then ok (¬ true)
       else ok true
  else if b
       then ok (¬ false)
       else ok false

/- [sha3::simple::rem_euclid_i8]:
   Source: 'src/simple.rs', lines 20:0-23:1 -/
def simple.rem_euclid_i8 (a : I8) (b : I8) : Result I8 :=
  do
  let a1 ← a % b
  if a1 < 0#i8
  then if b < 0#i8
       then a1 - b
       else a1 + b
  else ok a1

/- [sha3::simple::rem_euclid_isize]:
   Source: 'src/simple.rs', lines 24:0-27:1 -/
def simple.rem_euclid_isize (a : Isize) (b : Isize) : Result Isize :=
  do
  let a1 ← a % b
  if a1 < 0#isize
  then if b < 0#isize
       then a1 - b
       else a1 + b
  else ok a1

/- [sha3::simple::StateArray]
   Source: 'src/simple.rs', lines 30:0-30:29 -/
@[reducible] def simple.StateArray := (Array Bool 1600#usize)

/- Trait declaration: [core::default::Default]
   Source: '/rustc/library/core/src/default.rs', lines 107:0-107:24
   Name pattern: core::default::Default -/
structure core.default.Default (Self : Type) where
  default : Result Self

/- [sha3::simple::{core::default::Default for sha3::simple::StateArray}::default]:
   Source: 'src/simple.rs', lines 33:4-35:5 -/
def simple.Defaultsha3simpleStateArray.default : Result simple.StateArray :=
  let a := Array.repeat 1600#usize false
  ok a

/- Trait implementation: [sha3::simple::{core::default::Default for sha3::simple::StateArray}]
   Source: 'src/simple.rs', lines 32:0-36:1 -/
@[reducible]
def core.default.Defaultsha3simpleStateArray : core.default.Default
  simple.StateArray := {
  default := simple.Defaultsha3simpleStateArray.default
}

/- [sha3::simple::{core::clone::Clone for sha3::simple::StateArray}#1::clone]:
   Source: 'src/simple.rs', lines 39:4-41:5 -/
def simple.Clonesha3simpleStateArray.clone
  (self : simple.StateArray) : Result simple.StateArray :=
  ok self

/- Trait implementation: [sha3::simple::{core::clone::Clone for sha3::simple::StateArray}#1]
   Source: 'src/simple.rs', lines 38:0-42:1 -/
@[reducible]
def core.clone.Clonesha3simpleStateArray : core.clone.Clone simple.StateArray
  := {
  clone := simple.Clonesha3simpleStateArray.clone
}

/- [sha3::simple::{sha3::simple::StateArray}#2::index]:
   Source: 'src/simple.rs', lines 45:4-48:5 -/
def simple.StateArray.index
  (self : simple.StateArray) (index : (U8 × U8 × Usize)) : Result Bool :=
  do
  let (x, y, z) := index
  let i ← (↑(UScalar.cast .Usize y) : Result Usize)
  let i1 ← 5#usize * i
  let i2 ← (↑(UScalar.cast .Usize x) : Result Usize)
  let i3 ← i1 + i2
  let i4 ← simple.W * i3
  let i5 ← i4 + z
  Array.index_usize self i5

/- [sha3::simple::{sha3::simple::StateArray}#2::index_mut]:
   Source: 'src/simple.rs', lines 50:4-53:5 -/
def simple.StateArray.index_mut
  (self : simple.StateArray) (index : (U8 × U8 × Usize)) :
  Result (Bool × (Bool → simple.StateArray))
  :=
  do
  let (x, y, z) := index
  let i ← (↑(UScalar.cast .Usize y) : Result Usize)
  let i1 ← 5#usize * i
  let i2 ← (↑(UScalar.cast .Usize x) : Result Usize)
  let i3 ← i1 + i2
  let i4 ← simple.W * i3
  let i5 ← i4 + z
  let (b, index_mut_back) ← Array.index_mut_usize self i5
  let back := fun ret => let a := index_mut_back ret
                         a
  ok (b, back)

/- [sha3::simple::theta::theta_c]:
   Source: 'src/simple.rs', lines 57:4-71:5 -/
def simple.theta.theta_c
  (a : simple.StateArray) (x : U8) (z : Usize) : Result Bool :=
  do
  let b ← simple.StateArray.index a (x, 0#u8, z)
  let b1 ← simple.StateArray.index a (x, 1#u8, z)
  let b2 ← simple.StateArray.index a (x, 2#u8, z)
  let b3 ← simple.StateArray.index a (x, 3#u8, z)
  let b4 ← simple.StateArray.index a (x, 4#u8, z)
  let b5 ← simple.binxor b3 b4
  let b6 ← simple.binxor b2 b5
  let b7 ← simple.binxor b1 b6
  simple.binxor b b7

/- [sha3::simple::theta::theta_d]:
   Source: 'src/simple.rs', lines 72:4-77:5 -/
def simple.theta.theta_d
  (a : simple.StateArray) (x : U8) (z : Usize) : Result Bool :=
  do
  let i ← (↑(UScalar.hcast .I8 x) : Result I8)
  let i1 ← i - 1#i8
  let i2 ← simple.rem_euclid_i8 i1 5#i8
  let x1 ← (↑(IScalar.hcast .U8 i2) : Result U8)
  let i3 ← x + 1#u8
  let x2 ← i3 % 5#u8
  let i4 ← (↑(UScalar.hcast .Isize z) : Result Isize)
  let i5 ← i4 - 1#isize
  let i6 ← (↑(UScalar.hcast .Isize simple.W) : Result Isize)
  let i7 ← simple.rem_euclid_isize i5 i6
  let z2 ← (↑(IScalar.hcast .Usize i7) : Result Usize)
  let b ← simple.theta.theta_c a x1 z
  let b1 ← simple.theta.theta_c a x2 z2
  simple.binxor b b1

/- [sha3::simple::theta::theta_apply_a_inner::theta_apply_a_inner2]: loop 0:
   Source: 'src/simple.rs', lines 87:20-90:21 -/
divergent def simple.theta.theta_apply_a_inner.theta_apply_a_inner2_loop
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8)
  (z : Usize) :
  Result simple.StateArray
  :=
  if z < simple.W
  then
    do
    let b ← simple.StateArray.index a (x, y, z)
    let b1 ← simple.theta.theta_d a x z
    let b2 ← simple.binxor b b1
    let (_, index_mut_back) ← simple.StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b2
    simple.theta.theta_apply_a_inner.theta_apply_a_inner2_loop res1 a x y z1
  else ok res

/- [sha3::simple::theta::theta_apply_a_inner::theta_apply_a_inner2]:
   Source: 'src/simple.rs', lines 85:26-91:17 -/
@[reducible]
def simple.theta.theta_apply_a_inner.theta_apply_a_inner2
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8) :
  Result simple.StateArray
  :=
  simple.theta.theta_apply_a_inner.theta_apply_a_inner2_loop res a x y 0#usize

/- [sha3::simple::theta::theta_apply_a_inner]: loop 0:
   Source: 'src/simple.rs', lines 84:12-93:13 -/
divergent def simple.theta.theta_apply_a_inner_loop
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8) :
  Result simple.StateArray
  :=
  if y < 5#u8
  then
    do
    let res1 ←
      simple.theta.theta_apply_a_inner.theta_apply_a_inner2 res a x y
    let y1 ← y + 1#u8
    simple.theta.theta_apply_a_inner_loop res1 a x y1
  else ok res

/- [sha3::simple::theta::theta_apply_a_inner]:
   Source: 'src/simple.rs', lines 81:18-94:9 -/
@[reducible]
def simple.theta.theta_apply_a_inner
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) :
  Result simple.StateArray
  :=
  simple.theta.theta_apply_a_inner_loop res a x 0#u8

/- [sha3::simple::theta]: loop 0:
   Source: 'src/simple.rs', lines 80:4-96:5 -/
divergent def simple.theta_loop
  (a : simple.StateArray) (res : simple.StateArray) (x : U8) :
  Result simple.StateArray
  :=
  if x < 5#u8
  then
    do
    let res1 ← simple.theta.theta_apply_a_inner res a x
    let x1 ← x + 1#u8
    simple.theta_loop a res1 x1
  else ok res

/- [sha3::simple::theta]:
   Source: 'src/simple.rs', lines 56:0-98:1 -/
def simple.theta (a : simple.StateArray) : Result simple.StateArray :=
  do
  let res ← simple.Defaultsha3simpleStateArray.default
  simple.theta_loop a res 0#u8

/- [sha3::simple::rho_offset]:
   Source: 'src/simple.rs', lines 100:0-102:1 -/
def simple.rho_offset (t : Usize) : Result Isize :=
  do
  let i ← t + 1#usize
  let i1 ← t + 2#usize
  let i2 ← i * i1
  let i3 ← i2 / 2#usize
  ok (UScalar.hcast .Isize i3)

/- [sha3::simple::rho::rho_inner]: loop 0:
   Source: 'src/simple.rs', lines 111:12-115:13 -/
divergent def simple.rho.rho_inner_loop
  (res : simple.StateArray) (a : simple.StateArray) (t : Usize) (x : U8)
  (y : U8) (z : Usize) :
  Result simple.StateArray
  :=
  if z < simple.W
  then
    do
    let i ← (↑(UScalar.hcast .Isize z) : Result Isize)
    let i1 ← simple.rho_offset t
    let i2 ← i - i1
    let i3 ← (↑(UScalar.hcast .Isize simple.W) : Result Isize)
    let i4 ← simple.rem_euclid_isize i2 i3
    let z2 ← (↑(IScalar.hcast .Usize i4) : Result Usize)
    let b ← simple.StateArray.index a (x, y, z2)
    let (_, index_mut_back) ← simple.StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b
    simple.rho.rho_inner_loop res1 a t x y z1
  else ok res

/- [sha3::simple::rho::rho_inner]:
   Source: 'src/simple.rs', lines 109:8-116:9 -/
@[reducible]
def simple.rho.rho_inner
  (res : simple.StateArray) (a : simple.StateArray) (t : Usize) (x : U8)
  (y : U8) :
  Result simple.StateArray
  :=
  simple.rho.rho_inner_loop res a t x y 0#usize

/- [sha3::simple::rho]: loop 0:
   Source: 'src/simple.rs', lines 107:4-120:5 -/
divergent def simple.rho_loop
  (a : simple.StateArray) (x : U8) (y : U8) (res : simple.StateArray)
  (t : Usize) :
  Result simple.StateArray
  :=
  if t < 24#usize
  then
    do
    let res1 ← simple.rho.rho_inner res a t x y
    let i ← 2#u8 * x
    let i1 ← 3#u8 * y
    let i2 ← i + i1
    let lhs ← i2 % 5#u8
    let t1 ← t + 1#usize
    simple.rho_loop a y lhs res1 t1
  else ok res

/- [sha3::simple::rho]:
   Source: 'src/simple.rs', lines 103:0-122:1 -/
def simple.rho (a : simple.StateArray) : Result simple.StateArray :=
  do
  let res ← simple.Clonesha3simpleStateArray.clone a
  simple.rho_loop a 1#u8 0#u8 res 0#usize

/- [sha3::simple::pi::pi_inner::pi_inner2]: loop 0:
   Source: 'src/simple.rs', lines 135:20-140:21 -/
divergent def simple.pi.pi_inner.pi_inner2_loop
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8)
  (z : Usize) :
  Result simple.StateArray
  :=
  if z < simple.W
  then
    do
    let i ← 3#u8 * y
    let i1 ← x + i
    let x2 ← i1 % 5#u8
    let b ← simple.StateArray.index a (x2, x, z)
    let (_, index_mut_back) ← simple.StateArray.index_mut res (x, y, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b
    simple.pi.pi_inner.pi_inner2_loop res1 a x y z1
  else ok res

/- [sha3::simple::pi::pi_inner::pi_inner2]:
   Source: 'src/simple.rs', lines 133:16-141:17 -/
@[reducible]
def simple.pi.pi_inner.pi_inner2
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8) :
  Result simple.StateArray
  :=
  simple.pi.pi_inner.pi_inner2_loop res a x y 0#usize

/- [sha3::simple::pi::pi_inner]: loop 0:
   Source: 'src/simple.rs', lines 131:12-144:13 -/
divergent def simple.pi.pi_inner_loop
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8) :
  Result simple.StateArray
  :=
  if y < 5#u8
  then
    do
    let res1 ← simple.pi.pi_inner.pi_inner2 res a x y
    let y1 ← y + 1#u8
    simple.pi.pi_inner_loop res1 a x y1
  else ok res

/- [sha3::simple::pi::pi_inner]:
   Source: 'src/simple.rs', lines 129:8-145:9 -/
@[reducible]
def simple.pi.pi_inner
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) :
  Result simple.StateArray
  :=
  simple.pi.pi_inner_loop res a x 0#u8

/- [sha3::simple::pi]: loop 0:
   Source: 'src/simple.rs', lines 127:4-148:5 -/
divergent def simple.pi_loop
  (a : simple.StateArray) (res : simple.StateArray) (x : U8) :
  Result simple.StateArray
  :=
  if x < 5#u8
  then
    do
    let res1 ← simple.pi.pi_inner res a x
    let x1 ← x + 1#u8
    simple.pi_loop a res1 x1
  else ok res

/- [sha3::simple::pi]:
   Source: 'src/simple.rs', lines 124:0-150:1 -/
def simple.pi (a : simple.StateArray) : Result simple.StateArray :=
  do
  let res ← simple.Clonesha3simpleStateArray.clone a
  simple.pi_loop a res 0#u8

/- [sha3::simple::chi::chi_inner::chi_inner2]: loop 0:
   Source: 'src/simple.rs', lines 163:20-169:21 -/
divergent def simple.chi.chi_inner.chi_inner2_loop
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8)
  (z : Usize) :
  Result simple.StateArray
  :=
  if z < simple.W
  then
    do
    let i ← x + 1#u8
    let x1 ← i % 5#u8
    let i1 ← x + 2#u8
    let x2 ← i1 % 5#u8
    let b ← simple.StateArray.index a (x, y, z)
    let b1 ← simple.StateArray.index a (x1, y, z)
    let b2 ← simple.binxor b1 true
    if b2
    then
      do
      let b3 ← simple.StateArray.index a (x2, y, z)
      let b4 ← simple.binxor b b3
      let (_, index_mut_back) ← simple.StateArray.index_mut res (x, y, z)
      let z1 ← z + 1#usize
      let res1 := index_mut_back b4
      simple.chi.chi_inner.chi_inner2_loop res1 a x y z1
    else
      do
      let b3 ← simple.binxor b false
      let (_, index_mut_back) ← simple.StateArray.index_mut res (x, y, z)
      let z1 ← z + 1#usize
      let res1 := index_mut_back b3
      simple.chi.chi_inner.chi_inner2_loop res1 a x y z1
  else ok res

/- [sha3::simple::chi::chi_inner::chi_inner2]:
   Source: 'src/simple.rs', lines 161:16-170:17 -/
@[reducible]
def simple.chi.chi_inner.chi_inner2
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8) :
  Result simple.StateArray
  :=
  simple.chi.chi_inner.chi_inner2_loop res a x y 0#usize

/- [sha3::simple::chi::chi_inner]: loop 0:
   Source: 'src/simple.rs', lines 159:12-173:13 -/
divergent def simple.chi.chi_inner_loop
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) (y : U8) :
  Result simple.StateArray
  :=
  if y < 5#u8
  then
    do
    let res1 ← simple.chi.chi_inner.chi_inner2 res a x y
    let y1 ← y + 1#u8
    simple.chi.chi_inner_loop res1 a x y1
  else ok res

/- [sha3::simple::chi::chi_inner]:
   Source: 'src/simple.rs', lines 157:8-174:9 -/
@[reducible]
def simple.chi.chi_inner
  (res : simple.StateArray) (a : simple.StateArray) (x : U8) :
  Result simple.StateArray
  :=
  simple.chi.chi_inner_loop res a x 0#u8

/- [sha3::simple::chi]: loop 0:
   Source: 'src/simple.rs', lines 155:4-177:5 -/
divergent def simple.chi_loop
  (a : simple.StateArray) (res : simple.StateArray) (x : U8) :
  Result simple.StateArray
  :=
  if x < 5#u8
  then
    do
    let res1 ← simple.chi.chi_inner res a x
    let x1 ← x + 1#u8
    simple.chi_loop a res1 x1
  else ok res

/- [sha3::simple::chi]:
   Source: 'src/simple.rs', lines 152:0-179:1 -/
def simple.chi (a : simple.StateArray) : Result simple.StateArray :=
  do
  let res ← simple.Clonesha3simpleStateArray.clone a
  simple.chi_loop a res 0#u8

/- [sha3::simple::IOTA_RC_POINTS]
   Source: 'src/simple.rs', lines 182:0-196:15 -/
@[global_simps]
def simple.IOTA_RC_POINTS_body : Result (Array Bool 255#usize) :=
  ok
  (Array.make 255#usize [
    true, false, false, false, false, false, false, false, true, false, true,
    true, false, false, false, true, true, true, true, false, true, false,
    false, false, false, true, true, true, true, true, true, true, true, false,
    false, true, false, false, false, false, true, false, true, false, false,
    true, true, true, true, true, false, true, false, true, false, true, false,
    true, true, true, false, false, false, false, false, true, true, false,
    false, false, true, false, true, false, true, true, false, false, true,
    true, false, false, true, false, true, true, true, true, true, true, false,
    true, true, true, true, false, false, true, true, false, true, true, true,
    false, true, true, true, false, false, true, false, true, false, true,
    false, false, true, false, true, false, false, false, true, false, false,
    true, false, true, true, false, true, false, false, false, true, true,
    false, false, true, true, true, false, false, true, true, true, true,
    false, false, false, true, true, false, true, true, false, false, false,
    false, true, false, false, false, true, false, true, true, true, false,
    true, false, true, true, true, true, false, true, true, false, true, true,
    true, true, true, false, false, false, false, true, true, false, true,
    false, false, true, true, false, true, false, true, true, false, true,
    true, false, true, false, true, false, false, false, false, false, true,
    false, false, true, true, true, false, true, true, false, false, true,
    false, false, true, false, false, true, true, false, false, false, false,
    false, false, true, true, true, false, true, false, false, true, false,
    false, false, true, true, true, false, false, false
    ] (by native_decide))
@[global_simps, irreducible]
def simple.IOTA_RC_POINTS : Array Bool 255#usize :=
  eval_global simple.IOTA_RC_POINTS_body (by native_decide)

/- [sha3::simple::iota_rc_point]:
   Source: 'src/simple.rs', lines 198:0-202:1 -/
def simple.iota_rc_point (t : Usize) : Result Bool :=
  do
  let t1 ← t % 255#usize
  Array.index_usize simple.IOTA_RC_POINTS t1

/- [sha3::simple::iota_rc_init]: loop 0:
   Source: 'src/simple.rs', lines 206:4-209:5 -/
divergent def simple.iota_rc_init_loop
  (ir : Usize) (rc : Array Bool 64#usize) (j : Usize) :
  Result (Array Bool 64#usize)
  :=
  if j < simple.L
  then
    do
    let i ← 7#usize * ir
    let i1 ← j + i
    let b ← simple.iota_rc_point i1
    let i2 ← 1#usize <<< j
    let i3 ← i2 - 1#usize
    let rc1 ← Array.update rc i3 b
    let j1 ← j + 1#usize
    simple.iota_rc_init_loop ir rc1 j1
  else ok rc

/- [sha3::simple::iota_rc_init]:
   Source: 'src/simple.rs', lines 204:0-210:1 -/
@[reducible]
def simple.iota_rc_init
  (ir : Usize) (rc : Array Bool 64#usize) : Result (Array Bool 64#usize) :=
  simple.iota_rc_init_loop ir rc 0#usize

/- [sha3::simple::iota_a]: loop 0:
   Source: 'src/simple.rs', lines 214:4-217:5 -/
divergent def simple.iota_a_loop
  (res : simple.StateArray) (a : simple.StateArray) (rc : Array Bool 64#usize)
  (z : Usize) :
  Result simple.StateArray
  :=
  if z < simple.W
  then
    do
    let b ← simple.StateArray.index a (0#u8, 0#u8, z)
    let b1 ← Array.index_usize rc z
    let b2 ← simple.binxor b b1
    let (_, index_mut_back) ← simple.StateArray.index_mut res (0#u8, 0#u8, z)
    let z1 ← z + 1#usize
    let res1 := index_mut_back b2
    simple.iota_a_loop res1 a rc z1
  else ok res

/- [sha3::simple::iota_a]:
   Source: 'src/simple.rs', lines 212:0-218:1 -/
@[reducible]
def simple.iota_a
  (res : simple.StateArray) (a : simple.StateArray) (rc : Array Bool 64#usize)
  :
  Result simple.StateArray
  :=
  simple.iota_a_loop res a rc 0#usize

/- [sha3::simple::iota]:
   Source: 'src/simple.rs', lines 220:0-226:1 -/
def simple.iota
  (ir : Usize) (a : simple.StateArray) : Result simple.StateArray :=
  do
  let rc := Array.repeat 64#usize false
  let rc1 ← simple.iota_rc_init ir rc
  let res ← simple.Clonesha3simpleStateArray.clone a
  simple.iota_a res a rc1

/- [sha3::simple::round]:
   Source: 'src/simple.rs', lines 228:0-234:1 -/
def simple.round
  (a : simple.StateArray) (ir : Usize) : Result simple.StateArray :=
  do
  let a1 ← simple.theta a
  let a2 ← simple.rho a1
  let a3 ← simple.pi a2
  let a4 ← simple.chi a3
  simple.iota ir a4

/- [sha3::simple::keccak_p]: loop 0:
   Source: 'src/simple.rs', lines 239:4-242:5 -/
divergent def simple.keccak_p_loop
  (a : simple.StateArray) (ir : Usize) : Result Unit :=
  if ir < 24#usize
  then
    do
    let a1 ← simple.round a ir
    let ir1 ← ir + 1#usize
    simple.keccak_p_loop a1 ir1
  else ok ()

/- [sha3::simple::keccak_p]:
   Source: 'src/simple.rs', lines 236:0-244:1 -/
def simple.keccak_p
  (s : Array Bool 1600#usize) : Result (Array Bool 1600#usize) :=
  do
  simple.keccak_p_loop s 0#usize
  ok s

/- [sha3::simple::pad10_1]: loop 0:
   Source: 'src/simple.rs', lines 251:4-254:5 -/
divergent def simple.pad10_1_loop
  (j : Isize) (res : alloc.vec.Vec Bool) (i : Isize) :
  Result (alloc.vec.Vec Bool)
  :=
  if i < j
  then
    do
    let res1 ← alloc.vec.Vec.push res false
    let i1 ← i + 1#isize
    simple.pad10_1_loop j res1 i1
  else alloc.vec.Vec.push res true

/- [sha3::simple::pad10_1]:
   Source: 'src/simple.rs', lines 246:0-257:1 -/
def simple.pad10_1 (x : Usize) (m : Usize) : Result (alloc.vec.Vec Bool) :=
  do
  let i ← (↑(UScalar.hcast .Isize m) : Result Isize)
  let i1 ← -. i
  let i2 ← i1 - 2#isize
  let i3 ← (↑(UScalar.hcast .Isize x) : Result Isize)
  let j ← simple.rem_euclid_isize i2 i3
  let res ← alloc.vec.Vec.push (alloc.vec.Vec.new Bool) true
  simple.pad10_1_loop j res 0#isize

/- [sha3::simple::xor_long]: loop 0:
   Source: 'src/simple.rs', lines 263:4-266:5 -/
divergent def simple.xor_long_loop0
  (s : Slice Bool) (other : Slice Bool) (n : Usize) (i : Usize) :
  Result (Slice Bool)
  :=
  if i < n
  then
    do
    let b ← Slice.index_usize s i
    let b1 ← Slice.index_usize other i
    let b2 ← simple.binxor b b1
    let s1 ← Slice.update s i b2
    let i1 ← i + 1#usize
    simple.xor_long_loop0 s1 other n i1
  else ok s

/- [sha3::simple::xor_long]: loop 1:
   Source: 'src/simple.rs', lines 263:4-266:5 -/
divergent def simple.xor_long_loop1
  (s : Slice Bool) (other : Slice Bool) (n : Usize) (i : Usize) :
  Result (Slice Bool)
  :=
  if i < n
  then
    do
    let b ← Slice.index_usize s i
    let b1 ← Slice.index_usize other i
    let b2 ← simple.binxor b b1
    let s1 ← Slice.update s i b2
    let i1 ← i + 1#usize
    simple.xor_long_loop1 s1 other n i1
  else ok s

/- [sha3::simple::xor_long]:
   Source: 'src/simple.rs', lines 259:0-267:1 -/
def simple.xor_long
  (s : Slice Bool) (other : Slice Bool) : Result (Slice Bool) :=
  let i := Slice.len s
  let i1 := Slice.len other
  if i < i1
  then let n := Slice.len s
       simple.xor_long_loop0 s other n 0#usize
  else let n := Slice.len other
       simple.xor_long_loop1 s other n 0#usize

/- [sha3::simple::sponge_absorb]: loop 0:
   Source: 'src/simple.rs', lines 272:4-277:5 -/
divergent def simple.sponge_absorb_loop
  (bs : alloc.vec.Vec Bool) (r : Usize) (s : Array Bool 1600#usize) (n : Usize)
  (i : Usize) :
  Result (Array Bool 1600#usize)
  :=
  if i < n
  then
    do
    let i1 ← r * i
    let i2 ← i + 1#usize
    let i3 ← r * i2
    let chunk ←
      alloc.vec.Vec.index (core.slice.index.SliceIndexRangeUsizeSliceInst Bool)
        bs { start := i1, end_ := i3 }
    let (s1, to_slice_mut_back) ←
      (↑(Array.to_slice_mut s) : Result ((Slice Bool) × (Slice Bool →
         Array Bool 1600#usize)))
    let s2 ← simple.xor_long s1 chunk
    let s3 := to_slice_mut_back s2
    let s4 ← simple.keccak_p s3
    simple.sponge_absorb_loop bs r s4 n i2
  else ok s

/- [sha3::simple::sponge_absorb]:
   Source: 'src/simple.rs', lines 269:0-278:1 -/
def simple.sponge_absorb
  (bs : alloc.vec.Vec Bool) (r : Usize) (s : Array Bool 1600#usize) :
  Result (Array Bool 1600#usize)
  :=
  do
  let i := alloc.vec.Vec.len bs
  let n ← i / r
  simple.sponge_absorb_loop bs r s n 0#usize

/- Trait implementation: [core::marker::{core::marker::Copy for bool}#53]
   Source: '/rustc/library/core/src/marker.rs', lines 48:25-48:62
   Name pattern: core::marker::Copy<bool> -/
@[reducible]
def core.marker.CopyBool : core.marker.Copy Bool := {
  cloneInst := core.clone.CloneBool
}

/- [sha3::simple::sponge_squeze]: loop 0:
   Source: 'src/simple.rs', lines 281:4-290:5 -/
divergent def simple.sponge_squeze_loop
  (d : Usize) (r : Usize) (z : alloc.vec.Vec Bool) (s : Array Bool 1600#usize)
  :
  Result ((alloc.vec.Vec Bool) × (Array Bool 1600#usize))
  :=
  do
  let s1 ← (↑(Array.to_slice s) : Result (Slice Bool))
  let z1 ← simple.add_to_vec core.marker.CopyBool z s1 r
  let i := alloc.vec.Vec.len z1
  if d <= i
  then
    do
    let s2 ←
      alloc.vec.Vec.index (core.slice.index.SliceIndexRangeUsizeSliceInst Bool)
        z1 { start := 0#usize, end_ := d }
    let z2 ← alloc.slice.Slice.to_vec core.clone.CloneBool s2
    ok (z2, s)
  else do
       let s2 ← simple.keccak_p s
       simple.sponge_squeze_loop d r z1 s2

/- [sha3::simple::sponge_squeze]:
   Source: 'src/simple.rs', lines 280:0-291:1 -/
@[reducible]
def simple.sponge_squeze
  (d : Usize) (r : Usize) (z : alloc.vec.Vec Bool) (s : Array Bool 1600#usize)
  :
  Result ((alloc.vec.Vec Bool) × (Array Bool 1600#usize))
  :=
  simple.sponge_squeze_loop d r z s

/- [sha3::simple::my_extend]:
   Source: 'src/simple.rs', lines 293:0-295:1 -/
def simple.my_extend
  (bs : alloc.vec.Vec Bool) (other : alloc.vec.Vec Bool) :
  Result (alloc.vec.Vec Bool)
  :=
  let s := alloc.vec.Vec.deref other
  let i := alloc.vec.Vec.len other
  simple.add_to_vec core.marker.CopyBool bs s i

/- [sha3::simple::sponge]:
   Source: 'src/simple.rs', lines 297:0-304:1 -/
def simple.sponge
  (r : Usize) (bs : alloc.vec.Vec Bool) (d : Usize) :
  Result (alloc.vec.Vec Bool)
  :=
  do
  let m := alloc.vec.Vec.len bs
  let v ← simple.pad10_1 r m
  let bs1 ← simple.my_extend bs v
  let s := Array.repeat 1600#usize false
  let s1 ← simple.sponge_absorb bs1 r s
  let (bs2, _) ← simple.sponge_squeze d r (alloc.vec.Vec.new Bool) s1
  ok bs2

/- [sha3::simple::SHA3_SUFFIX]
   Source: 'src/simple.rs', lines 306:0-306:45 -/
@[global_simps]
def simple.SHA3_SUFFIX_body : Result (Array Bool 2#usize) :=
  ok (Array.make 2#usize [ false, true ])
@[global_simps, irreducible]
def simple.SHA3_SUFFIX : Array Bool 2#usize :=
  eval_global simple.SHA3_SUFFIX_body

/- [sha3::simple::sha3_224]:
   Source: 'src/simple.rs', lines 307:0-307:115 -/
def simple.sha3_224 (bs : alloc.vec.Vec Bool) : Result (alloc.vec.Vec Bool) :=
  do
  let s ← (↑(Array.to_slice simple.SHA3_SUFFIX) : Result (Slice Bool))
  let v ← alloc.slice.Slice.to_vec core.clone.CloneBool s
  let bs1 ← simple.my_extend bs v
  let i ← 2#usize * 224#usize
  let i1 ← simple.B - i
  simple.sponge i1 bs1 224#usize

/- [sha3::simple::sha3_256]:
   Source: 'src/simple.rs', lines 308:0-308:115 -/
def simple.sha3_256 (bs : alloc.vec.Vec Bool) : Result (alloc.vec.Vec Bool) :=
  do
  let s ← (↑(Array.to_slice simple.SHA3_SUFFIX) : Result (Slice Bool))
  let v ← alloc.slice.Slice.to_vec core.clone.CloneBool s
  let bs1 ← simple.my_extend bs v
  let i ← 2#usize * 256#usize
  let i1 ← simple.B - i
  simple.sponge i1 bs1 256#usize

/- [sha3::simple::sha3_384]:
   Source: 'src/simple.rs', lines 309:0-309:115 -/
def simple.sha3_384 (bs : alloc.vec.Vec Bool) : Result (alloc.vec.Vec Bool) :=
  do
  let s ← (↑(Array.to_slice simple.SHA3_SUFFIX) : Result (Slice Bool))
  let v ← alloc.slice.Slice.to_vec core.clone.CloneBool s
  let bs1 ← simple.my_extend bs v
  let i ← 2#usize * 384#usize
  let i1 ← simple.B - i
  simple.sponge i1 bs1 384#usize

/- [sha3::simple::sha3_512]:
   Source: 'src/simple.rs', lines 310:0-310:115 -/
def simple.sha3_512 (bs : alloc.vec.Vec Bool) : Result (alloc.vec.Vec Bool) :=
  do
  let s ← (↑(Array.to_slice simple.SHA3_SUFFIX) : Result (Slice Bool))
  let v ← alloc.slice.Slice.to_vec core.clone.CloneBool s
  let bs1 ← simple.my_extend bs v
  let i ← 2#usize * 512#usize
  let i1 ← simple.B - i
  simple.sponge i1 bs1 512#usize

/- [sha3::simple::SHAKE_SUFFIX]
   Source: 'src/simple.rs', lines 312:0-312:42 -/
@[global_simps]
def simple.SHAKE_SUFFIX_body : Result (Array Bool 4#usize) :=
  ok (Array.repeat 4#usize true)
@[global_simps, irreducible]
def simple.SHAKE_SUFFIX : Array Bool 4#usize :=
  eval_global simple.SHAKE_SUFFIX_body

/- [sha3::simple::shake128]:
   Source: 'src/simple.rs', lines 313:0-313:115 -/
def simple.shake128
  (bs : alloc.vec.Vec Bool) (d : Usize) : Result (alloc.vec.Vec Bool) :=
  do
  let s ← (↑(Array.to_slice simple.SHAKE_SUFFIX) : Result (Slice Bool))
  let v ← alloc.slice.Slice.to_vec core.clone.CloneBool s
  let bs1 ← simple.my_extend bs v
  let i ← 2#usize * 128#usize
  let i1 ← simple.B - i
  simple.sponge i1 bs1 d

/- [sha3::simple::shake256]:
   Source: 'src/simple.rs', lines 314:0-314:115 -/
def simple.shake256
  (bs : alloc.vec.Vec Bool) (d : Usize) : Result (alloc.vec.Vec Bool) :=
  do
  let s ← (↑(Array.to_slice simple.SHAKE_SUFFIX) : Result (Slice Bool))
  let v ← alloc.slice.Slice.to_vec core.clone.CloneBool s
  let bs1 ← simple.my_extend bs v
  let i ← 2#usize * 256#usize
  let i1 ← simple.B - i
  simple.sponge i1 bs1 d

end sha3
